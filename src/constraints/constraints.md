# Custom constraints
## Supervised learning case
It is possible that at some point you will want to enforce custom behavioral constraints that cannot be captured using the available interfaces. Depending on the type of constraint, this library supports the addition of custom user-defined constraints. The prerequisites that the constraint need to meet are as follows:
- You must be able to write a function, `$\hat{g}$(model,weights,data_dict)`, that provides (ideally) unbiased estimates of the constraint, `g`. 
- You must be able to uniquely define a string expression for this constraint or set of constraints. The expression need not be mathematical, but it needs to be unique from the existing strings in the list: `custom_ghat_strs` in [src/constraints.py](https://github.com/seldonian-framework/Seldonian/blob/main/src/constraints.py).


The way constraints are handled in this framework is in Python classes in the module: [src/constraints.py](https://github.com/seldonian-framework/Seldonian/blob/main/src/constraints.py). If your constraint does not fit into one of the existing constraint classes, and meets the two criteria above, then you may be able to define a new class for your constraint.  The steps you would need to take to do this are:
1. Define the string expression for your constraint (or set of constraints). It need not be a formula for the constraint, but it does need to uniquely identify this of constraint (or set of constraints). 
2. Define a class in `src/constraints.py` that inherits from the `BehavioralConstraint` class, ideally conforming to [upper camel case](https://en.wikipedia.org/wiki/Camel_case) and called something that uniquely identifies your constraint.
3. Define an `__init__()` method which at bare minimum takes a string expression as an argument. In the body of `__init__()` call the `__init__()` function of the parent class and pass it the `str_expression` argument, like so: `super().__init__(str_expression)`
4. Define a method, called `ghat` or some variant of that, of your custom class. Design this method to provide a vector of unbiased estimates of your constraint. If you have multiple constraints that can be calculated using this class, define a method for each of them. 
5. At a minimum, the ghat methods must take as input a model object, weight vector and data_dictionary.
6. If your constraints require preprocessing of the feature and/or label data before computing the bound, and the preprocessing is not dependent on the model weights, then define a method called `precalculate_data()` which takes the features and data as input (at a minimum) and returns a data dictionary and the number of observations in the potentially modified data, datasize. The idea here is that you don't want to re-run this preprocessing step each time you compute the bound in candidate selection. This method only gets run once at the beginning of candidate selection, and the result gets cached in the parse tree. Each subsequent time the confidence bound is calculated in candidate selection, the cached data is accessed rather than recomputed, potentially speeding up candidate selection enormously. 
7. Add an entry to the list `custom_ghat_strs` in [src/constraints.py](https://github.com/seldonian-framework/Seldonian/blob/main/src/constraints.py) with the string expression of your constraint.
8. Add an entry to the dictionary: `custom_ghat_dict` in the same file, where the key is the string expression of your constraint and the value is a dictionary like: `{'class':class_name,'method':ghat_method_name}`, where `class_name` is the name of the class you defined in step 2, and `ghat_method_name` is the name of the method you defined for ghat in step 4. 
9. In the interface (TODO: design interface to accept "custom-type" constraints) supply your custom behavioral constraints along with any parameters you wish to pass to your custom constraint class and the value of `$delta$` for the constraint. Note that you may supply normal constraints alongside custom constraints.  


An example of a new custom constraint class is already coded in [src/constraints.py](https://github.com/seldonian-framework/Seldonian/blob/main/src/constraints.py), called `ScienceGPARegressionConstraint`. This class is actually used to support two custom constraints, hence the two ghat methods of this class `ghat1()` and `ghat2()`. These were the constraints used in the Seldonian regression algorithm in the [Thomas et al. 2019 Science paper (see Figure 2)](https://www.science.org/stoken/author-tokens/ST-119/full). The strings corresponding to this constraint class are: `(y_i - y_hat_i | [M]) - (y_j - y_hat_j | [F]) - epsilon` and `(y_i - y_hat_i | [F]) - (y_j - y_hat_j | [M]) - epsilon`. The strings are purely descriptive; the contents of the strings themselves are not used to compute anything.

Notice in `custom_ghat_dict` that both strings use the same class, `ScienceGPARegressionConstraint`, but different methods.  The actual fairness constraints these represent were designed to ensure the prediction error `y_i - y_hat_i` between males `[M]` females `[F]` in a given dataset are less than or equal to a constant, `epsilon` (with probability `$1-\delta$`. Two constraints are used here because we wanted the prediction error difference in both directions (male - female) and (female - male) to be small.  

These fairness constraints are actually capturable in our interfaces via a single constraint: `abs((Mean_Error | [M]) - (Mean_Error | [F])) - epsilon`, where `epsilon` is a constant. However, it turns out that the confidence bound obtained using the two custom constraints is tighter than the one written using the interface. The ghat methods pair up the male and female observations in a way that cannot be done with the normal interfaces.

As mentioned above in step 6, The `precalculate_data()` method is used to speed up candidate selection. In this example, before the male and female data are paired up in the ghat methods, the feature and label vectors need to be filtered so that they have the same number of female and male observations. Importantly, this filtering does not depend on theta, the current weight vector of the model, so it only needs to be done once in candidate selection (and once in the safety test). Both ghat methods are written so that they accept the same data after it has been modified in `precalculate_data()`. 

(TODO: provide screenshot and more specific instructions once we have designed the interface) To supply these custom constraints to the interface, for each custom constraint, we:
- Indicate that we are using a custom constraint.
- Provide the string expression for the constraint
- Provide the value of epsilon (tolerance) for each constraint, in this case 0.05.
- Provide the value of delta (confidence threshold) for each constraint, in this case 0.025.